# Copyright 2017 The Wallaroo Authors.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
#  implied. See the License for the specific language governing
#  permissions and limitations under the License.


from collections import namedtuple
from datetime import datetime
from random import choice, randrange, randint, random
from string import lowercase
from struct import pack

FIXTYPE_ORDER = 1
FIXTYPE_MARKET_DATA = 2

SIDETYPE_BUY = 1
SIDETYPE_SELL = 2

reject_symbols_txt = """
    AA
    BAC
    AAPL
    FCX
    SUNE
    FB
    RAD
    INTC
    GE
    WMB
"""
no_reject_symbols_txt = """
    S
    ATML
    YHOO
    F
    T
    MU
    PFE
    CSCO
    MEG
    HUN
"""
SYMBOLS_REJECT = [s.rstrip().lstrip().rjust(4) for s in
           reject_symbols_txt.splitlines() if s]
SYMBOLS_NO_REJECT = [s.rstrip().lstrip().rjust(4) for s in
             no_reject_symbols_txt.splitlines() if s]


ORDERS_COUNTER = 1
REJECTED = {}
NOT_REJECTED = {}


def create_order(reject=False):
    global ORDERS_COUNTER
    global REJECTED
    fix_type = FIXTYPE_ORDER
    side = choice([SIDETYPE_BUY, SIDETYPE_SELL])  # isn't used
    account = randint(1,10)  # isn't used
    order_id = "{:06d}".format(ORDERS_COUNTER)  # isn't used
    ORDERS_COUNTER += 1  # isn't used
    qty = 1000.0  # isn't used
    price= 10  # isn't used
    transact_time = str(datetime.now())[:-5]  # isn't used
    if not reject:
        symbol = choice(NOT_REJECTED.keys())
        r = None
    else:
        symbol = choice(REJECTED.keys())
        rej = REJECTED[symbol]
        # note that we 0 for timestamp, as we can't compare it
        # with the one generated by the application
        # that part should be truncated from both records before
        # comparison
        r = pack(">HI6s4sddddQ", side, account, order_id, symbol,
                 qty, price, rej.bid, rej.offer, 0)
    o = pack(">BBI6s4sdd21s", fix_type, side, account, order_id,
                symbol, qty, price, transact_time)
    return (o, r)


MarketOrder = namedtuple("MarketOrder", ["bid", "offer"])
def create_market_data(reject=False):
    global REJECTED
    global NOT_REJECTED
    fix_type = FIXTYPE_MARKET_DATA
    transact_time = str(datetime.now())[:-5]
    bid = 1000
    if reject:
        symbol = choice(SYMBOLS_REJECT)
        # offer - bid
        offer_px = bid + 1
        REJECTED[symbol] = MarketOrder(bid, offer_px)
    else:
        symbol = choice(SYMBOLS_NO_REJECT)
        offer_px = bid + random()*0.05
        NOT_REJECTED[symbol] = MarketOrder(bid, offer_px)
    return pack(">B4s21sdd", fix_type, symbol, transact_time, bid,
         offer_px)


# Construct input sets: market, orders
# market is going to the second source address, and produces no output.
# orders should have some, but not all orders rejected.
FMT = ">I"
with open("_market.txt", "wb") as market, open("_orders.txt", "wb") as orders, open("_expected.txt", "wb") as expected:

    # generate market data
    for x in range(1000):
        p = create_market_data(reject=False)
        market.write(pack(FMT, len(p)))
        market.write(p)
    for x in range(1000):
        p = create_market_data(reject=True)
        market.write(pack(FMT, len(p)))
        market.write(p)

    # generate orders, some of which will be rejected
    for x in range(1000):
        o, r = create_order(reject=False)
        orders.write(pack(FMT, len(o)))
        orders.write(o)
        if r:
            expected.write(pack(FMT, len(r)))
            expected.write(r)
    for x in range(1000):
        o, r = create_order(reject=True)
        orders.write(pack(FMT, len(o)))
        orders.write(o)
        if r:
            expected.write(pack(FMT, len(r)))
            expected.write(r)
